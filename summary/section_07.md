# 스프링 핵심원리_기본편

## 다양한 의존관계 주입 방법

1. 다양한 의존관계 주입 방법

    - 생성자 주입

        - 생성자를 통해 의존관계를 주입 받는 방법

        - 특징
            - 생성자 호출 시점에 딱 한 번만 호출되는 것이 보장
                
                - 스프링은 두 가지 라이프사이클 존재 ()
                    - 빈 생성 단계
                    - 의존관계 주입 단계 (Autowired)

            * 생성자를 통한 의존관계 주입은 빈이 생성될 때 의존관계 주입!

            - 불변, 필수 의존관계에 사용

        * 생성자가 딱 1개 있으면 @Autowired 생략해도 자동 주입!!

    - 수정자 주입(setter 주입)

        - setter라는 수정자 메서드를 통해 주입

        - 특징
            - 선택, 변경 가능성이 있는 의존관계에 사용
            - 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법

            * 자바빈 프로퍼티, 자바에서는 과거부터 필드의 값을 직접 변경하지 않고, setXxx, getXxx 라는 메서드를 통해서 값을 읽거나 수정하는 규칙을 만들었는데, 그것이 자바빈 프로퍼티 규약
    
            - @Autowired(required = false) -> 파라미터 값이 없을수도 있을 때 사용

    - 필드 주입

        - 필드에 바로 주입

        - 특징
            - 외부에서 변경이 불가능해서 단위 테스트하기 어려움
            - DI 프레임워크가 없으면 아무것도 못함

    - 일반 메서드 주입

        - 일반 메서드를 통해 주입

        - 특징
            - 한 번에 여러 필드를 주입 받을 수 있다
            - 보통 생성자, 수정자에서 해결되기 때문에 잘 안쓰임
            - 메서드가 스프링 빈이어야 동작한다


2. 옵션처리

    - @Autowired(required = false) : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨

    - @Nullable : 자동 주입할 대상이 없으면 null이 입력

    - Optional<> : 자동 주입할 대상이 없으면 Optional.empty가 입력
    

3. 롬복과 최신 트렌드

    - Lombok(롬복)은 Java 라이브러리로 반복되는 getter, setter, toString 등의 메서드 작성 코드를 줄여주는 코드 다이어트 라이브러리입니다. 보통 Model 클래스나 Entity 같은 도메인 클래스 등에는 수많은 멤버변수가 있고 이에 대응되는 getter와 setter 그리고 toString() 메서드 그리고 때에 따라서는 멤버변수에 따른 여러개의 생성자를 만들어주게 되는데, 거의 대부분 이클립스같은 IDE의 힘만으로 생성한다고 하지만 이 역시도 번거로운 작업이 될 수 있습니다. 뿐만 아니라 코드 자체가 반복되는 메서드로 인해 매우 복잡해지게 됩니다.

    출처: https://dololak.tistory.com/783 [코끼리를 냉장고에 넣는 방법]

    - 최근에는 생성자를 하나 두고 @Autowired를 생략하는 방식을 많이 사용 (생성자가 1개일 경우에만 @Autowired 생략 가능!)

        - 여기에 Lombok의 @RequiredArgsConstructor를 사용하면 깔끔하게 코드를 정리 가능

4. 조회 빈이 2개 이상 - 문제

    - @Autowired는 타입으로 조회

    - 타입으로 조회하기 때문에 마치 다음 코드와 같이 작동한다 (실제로는 더 많은 기능을 제공)
        -ac.getBean(DiscountPolicy.class);

    - 같은 타입이 2개 이상일 경우, NoUniqueBeanDefinitionException 발생

    - 하위 타입으로 지정할 수 있지만, 이는 DIP위반 + 유연성 떨어짐

5. @Autowired 필드 명, @Qualifier, @Primary

    - 조회 빈이 2개 이상일 경우, 해결 방법은 세가지

        - @Autowired 필드 명 매칭
        
            - @Autowired는 타입 매칭을 시도하고, 이때 2개 이상이 있을경우 메서드명 or 파라미터 명으로 매칭 시도

            - 필드 명 매칭은 타입으로 매칭을 했을 때 여러 개가 있을 경우 작동하는 기능

        - @Qualifier

            - 추가 구분자를 붙여주는 방법

            - 주입 시 추가적인 방법을 제공하는 것이지, 빈의 이름을 변경하는 것이 아님

            - @Qualifier로 주입 시 먼저 @Qualifier를 찾고, 없을 경우 빈 이름에서 다시 찾는다

            - @Qualifier는 @Qualifier를 찾는 용도로만 사용하는 것이 좋다!

        - @Primary

            - @Autowired가 작동되고 여러 빈이 매칭되면 @Primary가 우선권을 가짐

    - @Qualify vs @Primary

        - @Qualify는 애노테이션을 일일이 붙여줘야함 하지만 @Primary는 그럴 필요 x

        - ex) 메인 Database 커넥션 빈과 서브 Database 커넥션 빈이 있을 때 (메인 빈 사용 빈도가 더 높음), 메인은 @Primary을 적용하고 서브를 @Qualify를 적용하면 깔끔하게 코드 유지 가능 (메인 빈을 @Qualify로 적용하는 건 상관없음)

    - 우선순위

        - @Primary는 기본 값처럼 동작하고 @Qualify는 상세히 동작

        - 스프링은 자동보다는 수동, 넓은 범위의 선택권 보다는 좁은 범위의 선택권이 우선순위 이므로 @Qualify가 우선순위!

6. 애노테이션 만들기

    - @Qualifier("abcd") <- 이럴 경우, 문자에 오타가 나더라도 컴파일 시 체크불가!
        -> 어노테이션을 만들어서 관리한다

    - 애노테이션에는 상속 기능 x

    - 여러 애노테이션을 모아서 사용하는 기능은 스프링에서 제공

    
7. 조회한 빈이 모두 필요할 때, List, Map

    - 주입 분석

        - Map <String, Object> : map의 key에 빈의 이름을 넣어주고, value에 Object 타입으로 조회한 모든 빈들을 담아준다

        - List<Object> : Object 타입으로 조회한 모든 스프링 빈을 담아준다
        
        * 만약 해당하는 빈이 없으면 빈 컬렉션이나 맵을 주입

    * 참고 - 스프링 컨테이너를 생성하면서 스프링 빈 등록하기

        - 스프링 컨테이너는 생성자에 클래스 정보를 받는다 여기에 클래스 정보를 넘기면 해당 클래스가 스프링 빈으로 등록된다
        
            - ex) new AnnotationConfigApplicationContext(AutoConfig.class, DiscountService.class);
        
            - 위 예시는 두 가지로 나누어 이해할 수 있음

                - new AnnotationConfigApplicationContext() 를 통해 스프링 컨테이너 생성

                - AutoConfig.class, DiscountService.class 를 파라미터로 넘기면서 해당 클래스를 스프링 빈으로 등록

            - 정리 => 스프링 컨테이너를 생성하면서 동시에 빈을 등록한다!


8. 자동, 수동의 올바른 실무 운영 기준

    - 편리한 자동 기능을 기본으로 사용!

        - 설정 정보를 기반으로 애플리케이션을 구성하는 부분과 실제 동작하는 부분을 명확하게 나누는 것이 이상적이지만, 과정이 번거로움

        - 관리할 빈이 많아질수록 설정 정보를 관리하는 것이 부담

        - 자동 기능을 사용해도 OCP, DIP를 지킬 수 있다!

    - 수동 기능은 언제 사용할까?

        - 애플리케이션은 크게 업무 로직 빈과 기술 지원 빈으로 나눌 수 있음

            - 업무 로직 빈
            
                - 컨트롤러, 리포지토리, 서비스 등이 해당, 보통 비즈니스 요구사항을 개발할 때 추가,변경됨

                - 개수가 많고 유사한 패턴이 많고 보통 문제가 발생해도 문제가 생긴 위치를 쉽게 파악 가능
                
                    -> 이런 경우 자동 기능이 유리!

            - 기술 지원 빈

                - 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용
                    - 데이터베이스 연결, 공통 로그 처리처럼 업무 로직을 지원하기 위한 하부 기술이나 공통 기술들

                - 개수가 적고, 애플리케이션 전반에 걸쳐 광범위하게 영향을 미침, 문제가 생겨도 파악이 어려움
                
                    -> 이런 경우 수동 기능이 유리!
                        - 수동 빈으로 등록해서 설정 정보에 바로 나타나게 하는 것이 유지보수에 좋다!

    * 비즈니스 로직 중에서 다형성을 적극 활용할 때

        - 어떤 빈들이 주입되는지 한 눈에 보기 어려워서 유지 보수가 어려워진다

        - 수동 빈으로 등록하거나, 자동으로 등록할 경우에는 같은 패키지로 관리하는 것이 좋다!


